# Algoritm(Interview)
 Practicing for Algoritm Interview

-- 기본적으로 내가 푼 답안과 강의 답안이 있습니다.

-- 강의 답안과 다른 답안이 나온 적도, 강의 답안이 더욱 효율적인 경우도, 혹은 내가 못 푼 경우도 있으니, 여기에 제시 되지 않은 답안을 가지고 계신분은 같이 공부해봤으면 좋겠습니다.

-------------------------------------------------------------------------------


-58. 이진트리 깊이 우선 탐색

    재귀 함수를 이용하여 모든 경우의 수를 찾음에 있어서, 배열의 flag를 활용하자.


-60. 합이 같은 부분집합

    위에서 모든 경우의 수를 위해 배열의 flag를 이용했다면 지금은 재귀 함수의 매개변수를 활용하도록 하자.

-61. 특정 수 만들기(DFS)

    DFS를 함에 있어서 꼭 이진트리 형태로 내려갈 필요가 없다.
    경우가 다양해 질 수록 많은 수의 가지를 뻗어나가면 된다.
    지금은 3가지의 경우를 생각하면 된다.
    이를 2번의 재귀 함수로 나눌 필요가 없다.
   
-62. 병합정렬

    어렵게 생각할 필요 없다. Left와 Mid, Right로 배열을 분할 한 후 임시 배열에 정렬해서 넣은 후 원래 배열에 복사하는 방식으로 풀어나가자. 재귀함수를 이용해서 분할 하자.

-63. 인접행렬

    인접행렬은 단방향과 양방향 그래프가 있고, 간선(Edge)과 정점(Vertex)로 구성되어있다. 
    여기에 각 간선에 가중치가 있을 수 있으며 이를 구현하는 방법으로 배열을 사용하는 방법 혹은 인접 리스트를 사용하는 방법이 있다.

-64. 경로탐색

    재귀 함수로 역시 정점과 간선을 통해 모든 경로를 찾자. 한가지 팁은 내가 방문한 정점을 확인할 flag를 보관하자.
    
-65. 미로탐색(DFS)

    어렵지 않다. 지금까지 재귀함수를 통해 모든 경우의 수를 찾았는데, 같은 방식으로 상하좌우의 경우를 다 찾으면 된다. 대신 배열의 범위를 벗어나지 않도록 하자.

-66. 경로탐색(인접리스트)

    기존의 DFS방식으로 경우의 수를 찾는건 똑같으나 간선과 정점의 정보를 리스트(백터)로 관리한다는 점이 다르다. 
    이렇게 되면 2차원 배열보다 검색의 수가 줄어들고 자료구조의 크기(메모리의 크기)를 줄일 수 있는 장점이 있다.

-67. 최소비용(인접행렬)
    지금까지의 경로탐색은 행렬의 값이 연결 유무를 나타냈으나 지금은 가중치를 나타내고 있으므로 정점으로 이동할 때마다 가중치의 합산을 계산해 주어야한다.
    그리고, 최소비용을 구하는 방법은 다익스트라 알고리즘이 있으니 이것을 공부하길 바란다.

-68. 최소비용(인접리스트)
    최소비용을 구하는 방법을 인접리스트 형태로 하는 것이 포인트. 이때는 Pair 자료구조를 이용하도록 하자.
    
-69. 이진 트리 넓이 우선 탐색(BFS)
    임의의 Queue를 구성하여 Front와 Back index로 삽입과 삭제를 구현하고, map에 무방향 인접 리스트를 구성한 다음 check배열로 확인하자.
    
-70. 그래프 최단거리(BFS)

    큐에 움직일 수 있는 경우의 수를 넣고 움직인 횟수는 이전 정점까지의 횟수 + 1하는 방식으로 구하면 쉽게 구할 수 있다.
   
-71. 송아지 찾기(BFS, 상대트리탐색)

    큐에 내가 움직일 수 있는 경우의 수를 넣고 하나 씩 빼가면서 목표지점인지 확인. 이미 들린 지점인 것을 확인하기 위한 flag 배열 또한 관리 필요.

-72. 공주 구하기(큐 자료구조 이용)

    이전에 풀었던 문제를 큐를 이용해서 푸는 문제이다. 조세퍼스를 기억하자. 특정 순서에 온 왕자는 빼고 아닌 왕자는 맨뒤로 돌려보내면 된다.
    
-73.74. 최대힙,최소힙(Priority Queue)

    우선순위 큐(Priority Queue)의 사용법에 관한 강의이다. 우선순위 큐는 vector 자료구조를 기반으로 완전이진트리 형태를 띄고있다. 여기에 다양한 데이터 구조를 인자로 넣을 수 있는데, 
    이때 우리는 bool operator()를 재정의 해서 다양한 데이터 구조를 오름차순 내림차순으로 정렬할 수 있다. 
    일반적으로 sort때와의 반환값과 반대인데, lhs > rhs이면 오름차순 lhs < rhs이면 내림차순이다. 

-75. 최대 수입 스케줄(Priority Queue)

    이 문제를 잘 이해하지 못해서 해맸었다. 대상 날짜에 가능한 여러 일들 중에 수입이 가장 높은걸 선택하면 되는데, 가능한 여러 일을 고르는게 어려웠다.
    
-76. 이항계수(메모이제이션)

    콤비네이션을 구하는 건 어렵지 않다. 팩토리얼 재귀함수를 만들어 공식에 따라 만들면 되지만 우리는 하나 더 배울 것이 있다.
    특정 콤비네이션 xCy는 x-1Cy-1(x를 포함한 경우) + x-1Cy(x를 포함하지 않는 경우)라는 것이다. 
    이를 이용해서 재귀함수를 만들자. 또한 재귀함수의 stack이 쌓여 나갈 때, 
    조금더 효율적인 연산을 위해 이미 구했던 경우의 경우 다시 연산하는 일이 없도록 연산 결과를 배열에 저장해 놓고 재활용 하는 방안(메모이제이션)을 사용하도록 하자.

-77. 친구인가(Union&Find 자료구조)

    이 자료구조는 트리형태로 구성된다. Union은 해당 대상을 연관된 그룹에 넣는 역할을 하고 Find는 해당 대상의 그룹을 반환하는 함수. 하지만 이렇게 되면 트리가 한쪽으로 쏠리는 현상이 나타나는데 이를 해결하기 위해 트리를 압축하자. 어디서? Find에서. 어떻게? 해당 대상의 그룹을 갱신하는 방식으로.
    
-78. 원더랜드(Kruskal MST 알고리즘 Union&Find활용)

    이전 문제에서 배운 분리집합, 교집합과 합집합 함수를 활용해보고, 꼭 외우도록 하자.
    Kruskal알고리즘은 최소신장트리 알고리즘 중 하나로써, 우선 모든 간선을 가중치를 기준으로 오름차순 정렬을 한다. 
    정렬된 간선들 중 가장 작은 간선부터 선택해 나가는데 선택했을 때 그래프 내 사이클이 생성된다면 해당 간선을 탈락시킨다. 
    그래프 내 사이클이 생성되는 지를 확인하기 위해 Union&Find 함수를 활용해야 한다.
    
-79. 원더랜드(Prim MST 알고리즘 Priorty_Queue활용)

    Kruskal 알고리즘과 목표는 같으나 방식이 다르다. 이 알고리즘은 우선 임의의 정점 하나를 선택한 후 가중치가 적은 간선을 선택해 나가 해를 구하는 방법이다.
    기억하자 이 알고리즘은 정점을 선택하는 것이 아니라 간선을 선택하는 것이다.
    
-80. 다익스트라 알고리즘

    Prim 알고리즘과 비슷하나 알고리즘 내부 구현에서 차이가 있다. 
    Prim알고리즘은 현재 정점과 연결된 간선 중에서 가중치가 가장 작은 간선을 선택했지만, 다익스트라 알고리즘은 현재 정점까지의 모든 가중치의 합을 비교한다.
